package org.example;

import java.util.Arrays;

public class KP_DP {//01背包问题

    public static void main(String[] args) {
        int[] w = {
                54,183,106,82,30,58,71,
                166,117,190,90,191,205,128,
                110,89,63,6,140,86,30,
                91,156,31,70,199,142,98,
                178,16,140,31,24,197,101,
                73,169,73,92,159,71,102,
                144,151,27,131,209,164,177,
                177,129,146,17,53,164,146,
                43,170,180,171,130,183,5,
                113,207,57,13,163,20,63,
                12,24,9,42,6,109,170,
                108,46,69,43,175,81,5,
                34,146,148,114,160,174,156,
                82,47,126,102,83,58,34,
                21,14};//物品的重量
        int[] val = {
                597,596,593,586,581,568,567,
                560,549,548,547,529,529,527,
                520,491,482,478,475,475,466,
                462,459,458,454,451,449,443,
                442,421,410,409,395,394,390,
                377,375,366,361,347,334,322,
                315,313,311,309,296,295,294,
                289,285,279,277,276,272,248,
                246,245,238,237,232,231,230,
                225,192,184,183,176,174,171,
                169,165,165,154,153,150,149,
                147,143,140,138,134,132,127,
                124,123,114,111,104,89,74,
                63,62,58,55,48,27,22,
                12,6};//物品的价值
        int m = 6178;//背包的容量
        int n = val.length;//物品的个数

        //为了记录放入商品的情况，我们定义一个二维数组
        int[][] path = new int[n + 1][m + 1];

        //创建二维数组
        //v[i][j]：表示在前i个物品中能够装入容量为j的背包中的最大价值
        int[][] v = new int[n + 1][m + 1];
        //初始化第一行和第一列【可有可无】
        for (int i = 0; i < v.length; i++) {//v.length:获取二维数组的行数
            v[i][0] = 0;//将第一列设置为0
        }
        for (int i = 0; i < v[0].length; i++) {//v[0].length：获取二维数组的列数
            v[0][i] = 0;//将第一行设置为0
        }

        //根据前面得到的公式来动态规划
        for (int i = 1; i < v.length; i++) {//int i = 1 不处理第一行
            for (int j = 1; j < v[0].length; j++) {//int j = 1 不处理第一列
                if (w[i - 1] > j) {//因为我们的程序的i是从1开始，所以原来公式里的w[i]-->>w[i-1]
                    v[i][j] = v[i - 1][j];//v[1][1]从第二行第二个开始
                } else {
                    //因为我们的程序的i是从1开始,因此要调整：
                    //为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，，需要使用if-else语句
                    if (v[i - 1][j] < (val[i - 1] + v[i - 1][j - w[i - 1]])) {
                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];
                        //把当前情况记录到path
                        path[i][j] = 1;
                    } else {
                        v[i][j] = v[i - 1][j];
                    }
                }
            }
        }

        //输出二维数组：
        for (int[] ints : v) {
            System.out.println(Arrays.toString(ints));
        }

        //输出最后我们是放入的那些商品
        int i = path.length - 1;//行的最大下标
        int j = path[0].length - 1;//列的最大下标
        while (i > 0 && j > 0) {//从path的最后开始找
            if (path[i][j] == 1) {
                System.out.printf("第%d个商品放入背包\n", i);
                j -= w[i - 1];
            }
            i--;
        }
    }
}
