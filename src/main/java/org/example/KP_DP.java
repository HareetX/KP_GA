package org.example;

import java.util.Arrays;

public class KP_DP {//01背包问题

    private int[] val = {
            597,596,593,586,581,568,567,
            560,549,548,547,529,529,527,
            520,491,482,478,475,475,466,
            462,459,458,454,451,449,443,
            442,421,410,409,395,394,390,
            377,375,366,361,347,334,322,
            315,313,311,309,296,295,294,
            289,285,279,277,276,272,248,
            246,245,238,237,232,231,230,
            225,192,184,183,176,174,171,
            169,165,165,154,153,150,149,
            147,143,140,138,134,132,127,
            124,123,114,111,104,89,74,
            63,62,58,55,48,27,22,
            12,6};//物品的价值
    private int[][] b = {{
            54,183,106,82,30,58,71,
            166,117,190,90,191,205,128,
            110,89,63,6,140,86,30,
            91,156,31,70,199,142,98,
            178,16,140,31,24,197,101,
            73,169,73,92,159,71,102,
            144,151,27,131,209,164,177,
            177,129,146,17,53,164,146,
            43,170,180,171,130,183,5,
            113,207,57,13,163,20,63,
            12,24,9,42,6,109,170,
            108,46,69,43,175,81,5,
            34,146,148,114,160,174,156,
            82,47,126,102,83,58,34,
            21,14}};//物品的重量
    private int[] pb = {6178};// 背包容积

    private int LL = 100;

    private int dimension = 1;

    public void solverKP() {
        // 为了记录放入商品的情况，我们定义一个二维数组
        int[][] path = new int[LL + 1][pb[0] + 1];

        // 创建二维数组
        // v[i][j]：表示在前i个物品中能够装入容量为j的背包中的最大价值
        int[][] v = new int[LL + 1][pb[0] + 1];
        // 初始化第一行和第一列【可有可无】
        for (int i = 0; i < v.length; i++) {//v.length:获取二维数组的行数
            v[i][0] = 0;//将第一列设置为0
        }
        for (int i = 0; i < v[0].length; i++) {//v[0].length：获取二维数组的列数
            v[0][i] = 0;//将第一行设置为0
        }

        // 动态规划
        for (int i = 1; i < v.length; i++) {//int i = 1 不处理第一行
            for (int j = 1; j < v[0].length; j++) {//int j = 1 不处理第一列
                if (b[0][i - 1] > j) {
                    v[i][j] = v[i - 1][j];//v[1][1]从第二行第二个开始
                } else {
                    //因为我们的程序的i是从1开始,因此要调整：
                    //为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，，需要使用if-else语句
                    if (v[i - 1][j] < (val[i - 1] + v[i - 1][j - b[0][i - 1]])) {
                        v[i][j] = val[i - 1] + v[i - 1][j - b[0][i - 1]];
                        //把当前情况记录到path
                        path[i][j] = 1;
                    } else {
                        v[i][j] = v[i - 1][j];
                    }
                }
            }
        }

        //输出二维数组：
        for (int[] ints : v) {
            System.out.println(Arrays.toString(ints));
        }

        //输出最后我们是放入的那些商品
        int i = path.length - 1;//行的最大下标
        int j = path[0].length - 1;//列的最大下标
        while (i > 0 && j > 0) {//从path的最后开始找
            if (path[i][j] == 1) {
                System.out.printf("第%d个商品放入背包\n", i);
                j -= b[0][i - 1];
            }
            i--;
        }
    }

    public static void main(String[] args) {
        KP_DP dp = new KP_DP();
        dp.solverKP();
    }
}
